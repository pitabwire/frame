package main

import (
	"errors"
	"flag"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

type config struct {
	ProtoDir  string
	OutDir    string
	EmbedDir  string
	Package   string
	BufBinary string
}

func main() {
	cfg := config{}
	flag.StringVar(&cfg.ProtoDir, "proto-dir", "proto", "Path to proto root (buf workspace or module)")
	flag.StringVar(&cfg.OutDir, "out", "pkg/openapi/specs", "Output directory for OpenAPI JSON")
	flag.StringVar(&cfg.EmbedDir, "embed-dir", "pkg/openapi", "Directory for generated embed.go")
	flag.StringVar(&cfg.Package, "package", "openapi", "Go package name for embed.go")
	flag.StringVar(&cfg.BufBinary, "buf", "buf", "Buf binary to execute")
	flag.Parse()

	if err := run(cfg); err != nil {
		fmt.Fprintln(os.Stderr, err.Error())
		os.Exit(1)
	}
}

func run(cfg config) error {
	protoDir, err := filepath.Abs(cfg.ProtoDir)
	if err != nil {
		return fmt.Errorf("resolve proto-dir: %w", err)
	}
	outDir, err := filepath.Abs(cfg.OutDir)
	if err != nil {
		return fmt.Errorf("resolve out dir: %w", err)
	}
	embedDir, err := filepath.Abs(cfg.EmbedDir)
	if err != nil {
		return fmt.Errorf("resolve embed dir: %w", err)
	}

	if err := os.MkdirAll(outDir, 0o755); err != nil {
		return fmt.Errorf("create out dir: %w", err)
	}
	if err := os.MkdirAll(embedDir, 0o755); err != nil {
		return fmt.Errorf("create embed dir: %w", err)
	}

	if err := generateOpenAPI(cfg.BufBinary, protoDir, outDir); err != nil {
		return err
	}

	if err := writeEmbedFile(embedDir, cfg.Package, protoDir, outDir); err != nil {
		return err
	}

	return nil
}

func generateOpenAPI(bufBinary, protoDir, outDir string) error {
	tpl, err := os.CreateTemp("", "frame-openapi-*.yaml")
	if err != nil {
		return fmt.Errorf("create buf template: %w", err)
	}
	defer func() {
		_ = os.Remove(tpl.Name())
	}()

	config := fmt.Sprintf(`version: v2
plugins:
  - remote: buf.build/community/sudorandom-connect-openapi
    out: %s
    opt:
      - features=connectrpc;gnostic;protovalidate
      - content-types=json
      - allow-get
`, outDir)

	if _, err := tpl.WriteString(config); err != nil {
		return fmt.Errorf("write buf template: %w", err)
	}
	if err := tpl.Close(); err != nil {
		return fmt.Errorf("close buf template: %w", err)
	}

	cmd := exec.Command(bufBinary, "generate", "--template", tpl.Name())
	cmd.Dir = protoDir
	out, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("buf generate failed: %w\n%s", err, strings.TrimSpace(string(out)))
	}

	return nil
}

func writeEmbedFile(embedDir, pkg, protoDir, outDir string) error {
	if pkg == "" {
		return errors.New("package name cannot be empty")
	}

	protoRel, protoOk := relPath(embedDir, protoDir)
	outRel, outOk := relPath(embedDir, outDir)
	goGenerate := ""
	if protoOk && outOk {
		goGenerate = fmt.Sprintf("//go:generate go run github.com/pitabwire/frame/tools/cmd/frame-openapi@latest -proto-dir %s -out %s -embed-dir . -package %s\n",
			protoRel, outRel, pkg)
	}

	content := fmt.Sprintf(`// Code generated by frame-openapi; DO NOT EDIT.
%spackage %s

import (
	"embed"

	"github.com/pitabwire/frame"
)

//go:embed specs/*.json
var SpecsFS embed.FS

// Option registers embedded OpenAPI specs with a Frame service.
func Option() frame.Option {
	return frame.WithOpenAPISpecsFromFS(SpecsFS, "specs")
}
`, goGenerate, pkg)

	path := filepath.Join(embedDir, "embed.go")
	return os.WriteFile(path, []byte(content), 0o644)
}

func relPath(base, target string) (string, bool) {
	rel, err := filepath.Rel(base, target)
	if err != nil {
		return "", false
	}
	if strings.HasPrefix(rel, "..") {
		return "", false
	}
	return rel, true
}
