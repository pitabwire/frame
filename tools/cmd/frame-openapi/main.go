package main

import (
	"context"
	"errors"
	"flag"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"
)

type config struct {
	ProtoDir  string
	OutDir    string
	EmbedDir  string
	Package   string
	BufBinary string
}

func main() {
	cfg := config{}
	flag.StringVar(&cfg.ProtoDir, "proto-dir", "proto", "Path to proto root (buf workspace or module)")
	flag.StringVar(&cfg.OutDir, "out", "pkg/openapi/specs", "Output directory for OpenAPI JSON")
	flag.StringVar(&cfg.EmbedDir, "embed-dir", "pkg/openapi", "Directory for generated embed.go")
	flag.StringVar(&cfg.Package, "package", "openapi", "Go package name for embed.go")
	flag.StringVar(&cfg.BufBinary, "buf", "buf", "Buf binary to execute")
	flag.Parse()

	if err := run(cfg); err != nil {
		fmt.Fprintln(os.Stderr, err.Error())
		os.Exit(1)
	}
}

func run(cfg config) error {
	protoDir, err := filepath.Abs(cfg.ProtoDir)
	if err != nil {
		return fmt.Errorf("resolve proto-dir: %w", err)
	}
	outDir, err := filepath.Abs(cfg.OutDir)
	if err != nil {
		return fmt.Errorf("resolve out dir: %w", err)
	}
	embedDir, err := filepath.Abs(cfg.EmbedDir)
	if err != nil {
		return fmt.Errorf("resolve embed dir: %w", err)
	}

	// #nosec G301 -- scaffold output should be readable by the developer.
	if mkErr := os.MkdirAll(outDir, 0o755); mkErr != nil {
		return fmt.Errorf("create out dir: %w", mkErr)
	}
	// #nosec G301 -- scaffold output should be readable by the developer.
	if mkErr := os.MkdirAll(embedDir, 0o755); mkErr != nil {
		return fmt.Errorf("create embed dir: %w", mkErr)
	}

	if genErr := generateOpenAPI(cfg.BufBinary, protoDir, outDir); genErr != nil {
		return genErr
	}

	if writeErr := writeEmbedFile(embedDir, cfg.Package, protoDir, outDir); writeErr != nil {
		return writeErr
	}

	return nil
}

func generateOpenAPI(bufBinary, protoDir, outDir string) error {
	tpl, err := os.CreateTemp("", "frame-openapi-*.yaml")
	if err != nil {
		return fmt.Errorf("create buf template: %w", err)
	}
	defer func() {
		// #nosec G703 -- temp file path is created by os.CreateTemp.
		_ = os.Remove(tpl.Name())
	}()

	config := fmt.Sprintf(`version: v2
plugins:
  - remote: buf.build/community/sudorandom-connect-openapi
    out: %s
    opt:
      - features=connectrpc;gnostic;protovalidate
      - content-types=json
      - allow-get
`, outDir)

	if _, writeErr := tpl.WriteString(config); writeErr != nil {
		return fmt.Errorf("write buf template: %w", writeErr)
	}
	if closeErr := tpl.Close(); closeErr != nil {
		return fmt.Errorf("close buf template: %w", closeErr)
	}

	ctx, cancel := context.WithTimeout(context.Background(), 15*time.Minute)
	defer cancel()

	// #nosec G204,G702 -- command is user-configured and expected in tooling.
	cmd := exec.CommandContext(ctx, bufBinary, "generate", "--template", tpl.Name())
	cmd.Dir = protoDir
	out, err := cmd.CombinedOutput()
	if err != nil {
		if ctx.Err() != nil {
			return fmt.Errorf("buf generate timed out: %w", ctx.Err())
		}
		return fmt.Errorf("buf generate failed: %w\n%s", err, strings.TrimSpace(string(out)))
	}

	return nil
}

func writeEmbedFile(embedDir, pkg, protoDir, outDir string) error {
	if pkg == "" {
		return errors.New("package name cannot be empty")
	}

	protoRel, protoOk := relPath(embedDir, protoDir)
	outRel, outOk := relPath(embedDir, outDir)
	goGenerate := ""
	if protoOk && outOk {
		goGenerate = fmt.Sprintf(
			"//go:generate go run github.com/pitabwire/frame/tools/cmd/frame-openapi@latest -proto-dir %s -out %s -embed-dir . -package %s\n",
			protoRel,
			outRel,
			pkg,
		)
	}

	content := fmt.Sprintf(`// Code generated by frame-openapi; DO NOT EDIT.
%spackage %s

import (
	"embed"

	"github.com/pitabwire/frame"
)

//go:embed specs/*.json
var SpecsFS embed.FS

// Option registers embedded OpenAPI specs with a Frame service.
func Option() frame.Option {
	return frame.WithOpenAPISpecsFromFS(SpecsFS, "specs")
}
`, goGenerate, pkg)

	path := filepath.Join(embedDir, "embed.go")
	// #nosec G306 -- generated files should be readable by the developer.
	return os.WriteFile(path, []byte(content), 0o644)
}

func relPath(base, target string) (string, bool) {
	rel, err := filepath.Rel(base, target)
	if err != nil {
		return "", false
	}
	return rel, true
}
